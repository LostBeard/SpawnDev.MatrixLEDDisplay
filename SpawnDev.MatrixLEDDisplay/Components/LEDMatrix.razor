@using SpawnDev.BlazorJS
@using SpawnDev.BlazorJS.JSObjects
@using SpawnDev.MatrixLEDDisplay.ImageTools
@using System.Timers
@using Timer = System.Timers.Timer;
@implements IDisposable

<div style="@Style">
    <div>
        <canvas style="border: 1px solid grey;" @ref=_canvasRef></canvas>
    </div>
    <div style="@(Display.SourceIsSlideShow && Display.SlideShowFrameCount > 0 ? "" : "display: none;")">
        @(ImageIndex + 1) / @Display.SlideShowFrameCount
    </div>
</div>

@code {
    [Inject]
    BlazorJSRuntime JS { get; set; } = default!;

    [Parameter]
    public string Style { get; set; } = "";

    [Parameter]
    public MIMatrixDisplay Display { get; set; }

    MIMatrixDisplay? _Display;

    ElementReference _canvasRef;

    HTMLCanvasElement? _canvas;
    CanvasRenderingContext2D? _ctx;

    [Parameter]
    public EventCallback<MouseEventArgs> OnMouseEvent { get; set; }

    int _blockSize = 0;
    int _canvasSize = 320;
    string _boxBorderColor = "black";
    int _pixelWidth = 16;
    int _pixelHeight = 16;

    Timer _tmr = new Timer();
    public void Dispose()
    {
        _tmr.Enabled = false;
        _tmr.Dispose();
        DetachDisplayEvents();
    }
    void DrawData()
    {
        if (_canvas == null || _ctx == null) return;
        var data = Display.GetFrame(ImageIndex);
        var width = data.Width * _blockSize;
        var height = data.Height * _blockSize;
        if (_canvas.Width != width || _canvas.Height != height)
        {
            _canvas.Width = width;
            _canvas.Height = height;
        }
        data.ForEachXY((x, y) =>
        {
            var color = data[x, y];
            var x1 = x * _blockSize;
            var y1 = y * _blockSize;
            _ctx!.FillStyle = color.HexColor;
            _ctx.FillRect(x1, y1, _blockSize, _blockSize);
            var strokeColor = Convert.ToHexString(new byte[] { 0, 0, 0, 128 });
            _ctx.StrokeStyle = $"#{strokeColor}";
            _ctx.StrokeRect(x1, y1, _blockSize, _blockSize);
        });
    }
    void DetachDisplayEvents()
    {
        if (_Display == null) return;
        _Display.OnStateChanged -= _Display_OnStateHasChanged;
        _Display = null;
    }
    void _Display_OnStateHasChanged(MIMatrixDisplay display)
    {
        StateHasChanged();
    }
    bool _attached = false;
    protected override void OnParametersSet()
    {
        if (_Display != Display)
        {
            DetachDisplayEvents();
            _Display = Display;
            if (_Display != null)
            {
                _Display.OnStateChanged -= _Display_OnStateHasChanged;
            }
        }
    }
    int ImageIndex => Display.SlideShowFrameCount == 0 ? 0 : _imageIndex % Display.SlideShowFrameCount;
    int _imageIndex = 0;
    void timer_elapsed(object? sender, ElapsedEventArgs e)
    {
        _imageIndex = _imageIndex == int.MaxValue ? 0 : _imageIndex + 1;
        StateHasChanged();
    }
    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            _canvas = new HTMLCanvasElement(_canvasRef);
            _ctx = _canvas.Get2DContext(new CanvasRenderingContext2DSettings { WillReadFrequently = true });
            _blockSize = (int)Math.Floor(_canvasSize / (double)_pixelWidth);
            _canvasSize = (int)(_blockSize * _pixelWidth); // 16 blocks + 1 pixel border between each block
            _canvas.Width = _canvasSize;
            _canvas.Height = _canvasSize;
            _tmr.Elapsed += timer_elapsed;
            _tmr.Interval = 650;
            _tmr.Enabled = true;
        }
        DrawData();
    }
}
